# 菜单题漏洞分析报告

## 程序概述

**程序名称**: all-pwn-red-book/pwn  
**程序类型**: C++ 菜单程序  
**架构**: x86_64  
**保护机制**: 栈保护 (Stack Canary), seccomp沙箱  

## 静态分析结果

### 1. 程序结构

程序是一个笔记管理系统，具有以下功能：
- 创建笔记 (3种类型)
- 显示笔记
- 编辑笔记内容
- 删除笔记
- 退出程序

### 2. 笔记类型系统

程序支持三种笔记类型：
1. **CheckinNotes** (类型1) - 签到笔记
2. **ProductReviews** (类型2) - 产品评论
3. **ConfessionPosts** (类型3) - 忏悔帖子

每种类型都有对应的虚函数表：
- `_vtable_for_CheckinNotes{for 'Note'}`
- `_vtable_for_ProductReviews{for 'Note'}`
- `_vtable_for_ConfessionPosts{for 'Note'}`

### 3. 关键函数分析

#### 主要菜单函数
- `sub_469100` - 创建笔记
- `sub_4692f0` - 显示笔记
- `sub_469420` - 显示笔记内容
- `sub_4695c0` - 设置笔记内容
- `sub_469760` - 删除笔记

#### 核心管理函数
- `sub_46a7f0` - 获取笔记数量
- `sub_46a810` - 添加笔记到数组
- `sub_46a8c0` - 重新分配笔记数组
- `sub_469bc0` - 删除笔记的关键函数
- `sub_469c20` - 笔记数组操作
- `sub_469c50` - 笔记删除后的清理

## 潜在漏洞分析

### 1. Use After Free (UAF) 漏洞

**位置**: `sub_469760` (删除笔记函数)

**分析**:
- 在删除笔记时，笔记被释放但指针可能没有被正确清理
- `sub_469bc0`函数返回已删除笔记的指针
- 后续访问可能触发UAF

**利用方法**:
```python
# 创建笔记
note1 = create_note(1, "Test content")
note2 = create_note(2, "Test content 2")

# 删除第一个笔记
delete_note(note1)

# 尝试访问已删除的笔记 - 可能触发UAF
display_note(note1)
```

### 2. 类型混淆漏洞

**位置**: 虚函数表系统

**分析**:
- 不同笔记类型有不同的虚函数表
- 如果类型检查不当，可能导致虚函数表混淆
- 可能通过UAF触发类型混淆

**利用方法**:
```python
# 创建不同类型的笔记
note1 = create_note(1, "CheckinNotes")  # 虚函数表: _vtable_for_CheckinNotes
note2 = create_note(2, "ProductReviews")  # 虚函数表: _vtable_for_ProductReviews

# 删除第一个笔记
delete_note(note1)

# 创建新笔记，可能重用已释放的内存
new_note = create_note(1, "New note")

# 尝试访问已删除的笔记
display_note(note1)  # 可能触发类型混淆
```

### 3. 堆管理问题

**位置**: `sub_46a8c0` (笔记数组重新分配)

**分析**:
- 笔记数组的重新分配可能存在问题
- 可能存在堆溢出或双重释放
- 堆喷射可能用于稳定利用

### 4. 整数溢出

**位置**: 笔记编号和内容长度检查

**分析**:
- 笔记编号的边界检查可能不充分
- 内容长度的检查可能存在问题

## 动态测试结果

### GDB调试结果

通过GDB调试发现：
- 程序正常启动，内存布局正常
- 堆管理使用标准的malloc/free
- 栈保护机制已启用
- seccomp沙箱限制系统调用

### 内存布局分析

```
Start Addr           End Addr       Size     Offset  Perms  objfile
0x555555554000     0x5555555ba000    0x66000        0x0  r--p   /home/sekiro/pwnTest/xctf25/all-pwn-red-book/pwn
0x5555555ba000     0x5555557e2000   0x228000    0x66000  r-xp   /home/sekiro/pwnTest/xctf25/all-pwn-red-book/pwn
0x5555557e2000     0x5555558a8000    0xc6000   0x28e000  r--p   /home/sekiro/pwnTest/xctf25/all-pwn-red-book/pwn
0x5555558a8000     0x555555900000    0x58000   0x353000  rw-p   /home/sekiro/pwnTest/xctf25/all-pwn-red-book/pwn
0x555555900000     0x555555903000     0x3000        0x0  rw-p   [heap]
0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
```

## 漏洞利用建议

### 1. UAF漏洞利用

**步骤**:
1. 创建多个笔记
2. 删除目标笔记
3. 尝试访问已删除的笔记
4. 分析返回的数据

**预期结果**:
- 可能泄露堆内存内容
- 可能触发崩溃
- 可能实现代码执行

### 2. 类型混淆利用

**步骤**:
1. 创建不同类型的笔记
2. 删除特定类型的笔记
3. 创建新笔记重用内存
4. 访问已删除的笔记

**预期结果**:
- 虚函数表混淆
- 可能的代码执行

### 3. 堆喷射利用

**步骤**:
1. 创建大量笔记
2. 删除部分笔记
3. 创建新笔记
4. 尝试访问已删除的笔记

**预期结果**:
- 稳定的UAF利用
- 可能的信息泄露

## 安全机制绕过

### 1. 栈保护绕过

- 使用UAF泄露栈canary
- 通过堆溢出覆盖返回地址

### 2. seccomp沙箱绕过

- 分析允许的系统调用
- 寻找ROP链利用方法

## 工具和脚本

### 已创建的脚本

1. **fuzz_script.py** - 模糊测试脚本
2. **exploit_script.py** - pwntools交互脚本
3. **advanced_exploit.py** - 高级漏洞分析脚本
4. **targeted_exploit.py** - 针对性漏洞利用脚本
5. **gdb_exploit.py** - GDB调试脚本
6. **run_uaf_test.sh** - UAF测试脚本
7. **run_memory_analysis.sh** - 内存分析脚本
8. **run_interactive_debug.sh** - 交互式调试脚本

### 使用方法

```bash
# 基础测试
python3 test_binary.py ./all-pwn-red-book/pwn

# 模糊测试
python3 fuzz_script.py ./all-pwn-red-book/pwn

# 针对性漏洞利用
python3 targeted_exploit.py ./all-pwn-red-book/pwn

# GDB调试
./run_uaf_test.sh
./run_memory_analysis.sh
./run_interactive_debug.sh
```

## 下一步计划

1. **深入动态测试**: 使用GDB进行更详细的调试
2. **漏洞验证**: 验证UAF和类型混淆漏洞
3. **利用开发**: 开发完整的漏洞利用脚本
4. **绕过安全机制**: 绕过栈保护和seccomp
5. **代码执行**: 实现最终的代码执行

## 结论

通过静态分析和初步的动态测试，发现了多个潜在的漏洞点，特别是UAF和类型混淆漏洞。建议继续使用GDB进行深入的动态调试，验证这些漏洞的可利用性。
