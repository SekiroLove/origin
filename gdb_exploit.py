#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GDB调试脚本
结合GDB进行动态调试和漏洞分析
"""

import subprocess
import time
import os
import sys
from pwn import *

class GDBExploit:
    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.gdb_script = "gdb_script.gdb"
        self.io = None
        
    def create_gdb_script(self):
        """创建GDB调试脚本"""
        gdb_commands = """
# GDB调试脚本 - 菜单题漏洞分析
set pagination off
set confirm off

# 设置断点
break main
break *0x469100  # 创建笔记函数
break *0x4692f0  # 显示笔记函数
break *0x469420  # 显示笔记内容函数
break *0x4695c0  # 设置笔记内容函数
break *0x469760  # 删除笔记函数

# 设置内存断点
break *0x469bc0  # 删除笔记时的关键函数
break *0x469c20  # 笔记数组操作
break *0x469c50  # 笔记删除后的清理

# 设置虚函数表相关断点
break *0x46a7f0  # 笔记数量获取
break *0x46a810  # 笔记数组添加
break *0x46a8c0  # 笔记数组重新分配

# 设置堆相关断点
break malloc
break free
break realloc

# 设置格式化输出断点
break printf
break puts

# 运行程序
run

# 等待用户输入
echo 程序已启动，等待用户操作...\\n
continue
"""
        
        with open(self.gdb_script, 'w') as f:
            f.write(gdb_commands)
        
        print(f"[+] 已创建GDB脚本: {self.gdb_script}")
    
    def run_gdb_debug(self):
        """运行GDB调试"""
        print("[+] 启动GDB调试...")
        
        # 创建GDB脚本
        self.create_gdb_script()
        
        # 启动GDB
        cmd = f"gdb -x {self.gdb_script} {self.binary_path}"
        print(f"[+] 执行命令: {cmd}")
        
        try:
            process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            
            # 发送一些测试命令
            test_commands = [
                "1\n",  # 创建笔记
                "1\n",  # 笔记类型1
                "Test content\n",  # 笔记内容
                "3\n",  # 显示笔记内容
                "0\n",  # 笔记编号
                "5\n",  # 删除笔记
                "0\n",  # 笔记编号
                "3\n",  # 尝试访问已删除的笔记
                "0\n",  # 笔记编号
                "6\n",  # 退出
            ]
            
            for cmd in test_commands:
                process.stdin.write(cmd)
                process.stdin.flush()
                time.sleep(0.5)
            
            # 获取输出
            stdout, stderr = process.communicate(timeout=30)
            
            print("[+] GDB调试输出:")
            print(stdout)
            
            if stderr:
                print("[+] GDB错误输出:")
                print(stderr)
                
        except subprocess.TimeoutExpired:
            process.kill()
            print("[-] GDB调试超时")
        except Exception as e:
            print(f"[-] GDB调试错误: {e}")
    
    def create_interactive_gdb_script(self):
        """创建交互式GDB脚本"""
        gdb_commands = """
# 交互式GDB调试脚本
set pagination off
set confirm off

# 设置断点
break main
break *0x469100  # 创建笔记
break *0x4692f0  # 显示笔记
break *0x469420  # 显示笔记内容
break *0x4695c0  # 设置笔记内容
break *0x469760  # 删除笔记

# 设置关键函数断点
break *0x469bc0  # 删除笔记关键函数
break *0x469c20  # 笔记数组操作
break *0x469c50  # 笔记删除清理

# 设置堆断点
break malloc
break free

# 运行程序
run

# 显示当前状态
echo 程序已启动，可以开始调试\\n
echo 可用命令:\\n
echo  1. 创建笔记\\n
echo  2. 显示笔记\\n
echo  3. 显示笔记内容\\n
echo  4. 设置笔记内容\\n
echo  5. 删除笔记\\n
echo  6. 退出\\n
echo 使用 'continue' 继续执行\\n
echo 使用 'info registers' 查看寄存器\\n
echo 使用 'x/10x $rsp' 查看栈\\n
echo 使用 'x/10x $rax' 查看返回值\\n
echo 使用 'bt' 查看调用栈\\n
echo 使用 'info breakpoints' 查看断点\\n
echo 使用 'delete breakpoints' 删除所有断点\\n
echo 使用 'quit' 退出GDB\\n
"""
        
        with open("interactive_gdb.gdb", 'w') as f:
            f.write(gdb_commands)
        
        print("[+] 已创建交互式GDB脚本: interactive_gdb.gdb")
    
    def run_interactive_gdb(self):
        """运行交互式GDB"""
        print("[+] 启动交互式GDB调试...")
        
        # 创建交互式GDB脚本
        self.create_interactive_gdb_script()
        
        # 启动GDB
        cmd = f"gdb -x interactive_gdb.gdb {self.binary_path}"
        print(f"[+] 执行命令: {cmd}")
        print("[+] 请在GDB中手动操作程序...")
        
        try:
            subprocess.run(cmd, shell=True)
        except Exception as e:
            print(f"[-] GDB调试错误: {e}")
    
    def create_pwntools_gdb_script(self):
        """创建结合pwntools的GDB脚本"""
        print("[+] 创建pwntools GDB调试脚本...")
        
        try:
            # 使用pwntools启动GDB
            self.io = process(self.binary_path)
            self.io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
            print("[+] 已连接到程序")
            
            # 附加GDB
            gdb.attach(self.io, gdbscript="""
# 设置断点
break *0x469100  # 创建笔记
break *0x4692f0  # 显示笔记
break *0x469420  # 显示笔记内容
break *0x4695c0  # 设置笔记内容
break *0x469760  # 删除笔记

# 设置关键函数断点
break *0x469bc0  # 删除笔记关键函数
break *0x469c20  # 笔记数组操作
break *0x469c50  # 笔记删除清理

# 设置堆断点
break malloc
break free

# 显示当前状态
echo 程序已启动，可以开始调试\\n
echo 可用命令:\\n
echo  1. 创建笔记\\n
echo  2. 显示笔记\\n
echo  3. 显示笔记内容\\n
echo  4. 设置笔记内容\\n
echo  5. 删除笔记\\n
echo  6. 退出\\n
echo 使用 'continue' 继续执行\\n
echo 使用 'info registers' 查看寄存器\\n
echo 使用 'x/10x $rsp' 查看栈\\n
echo 使用 'x/10x $rax' 查看返回值\\n
echo 使用 'bt' 查看调用栈\\n
echo 使用 'info breakpoints' 查看断点\\n
echo 使用 'delete breakpoints' 删除所有断点\\n
echo 使用 'quit' 退出GDB\\n
""")
            
            print("[+] GDB已附加到进程")
            print("[+] 请在GDB中手动操作程序...")
            
            # 等待用户操作
            input("按回车键继续...")
            
        except Exception as e:
            print(f"[-] pwntools GDB调试错误: {e}")
        finally:
            if self.io:
                self.io.close()
    
    def create_memory_analysis_script(self):
        """创建内存分析脚本"""
        gdb_commands = """
# 内存分析GDB脚本
set pagination off
set confirm off

# 设置断点
break main
break *0x469100  # 创建笔记
break *0x469760  # 删除笔记

# 运行程序
run

# 创建笔记
echo 创建笔记...\\n
continue

# 显示内存布局
echo 显示内存布局...\\n
info proc mappings
echo \\n

# 显示堆信息
echo 显示堆信息...\\n
info proc stat
echo \\n

# 显示当前笔记数组
echo 显示当前笔记数组...\\n
x/20x $rax
echo \\n

# 删除笔记
echo 删除笔记...\\n
continue

# 显示删除后的内存状态
echo 显示删除后的内存状态...\\n
x/20x $rax
echo \\n

# 尝试访问已删除的笔记
echo 尝试访问已删除的笔记...\\n
continue

# 显示访问时的内存状态
echo 显示访问时的内存状态...\\n
x/20x $rax
echo \\n

# 退出
quit
"""
        
        with open("memory_analysis.gdb", 'w') as f:
            f.write(gdb_commands)
        
        print("[+] 已创建内存分析脚本: memory_analysis.gdb")
    
    def run_memory_analysis(self):
        """运行内存分析"""
        print("[+] 运行内存分析...")
        
        # 创建内存分析脚本
        self.create_memory_analysis_script()
        
        # 运行GDB
        cmd = f"gdb -x memory_analysis.gdb {self.binary_path}"
        print(f"[+] 执行命令: {cmd}")
        
        try:
            subprocess.run(cmd, shell=True)
        except Exception as e:
            print(f"[-] 内存分析错误: {e}")
    
    def create_vulnerability_test_script(self):
        """创建漏洞测试脚本"""
        gdb_commands = """
# 漏洞测试GDB脚本
set pagination off
set confirm off

# 设置断点
break main
break *0x469100  # 创建笔记
break *0x469760  # 删除笔记
break *0x469420  # 显示笔记内容

# 运行程序
run

# 测试UAF漏洞
echo 测试UAF漏洞...\\n
echo 创建笔记1...\\n
continue
echo 创建笔记2...\\n
continue
echo 删除笔记1...\\n
continue
echo 尝试访问已删除的笔记1...\\n
continue

# 检查是否触发UAF
echo 检查是否触发UAF...\\n
info registers
echo \\n
x/10x $rsp
echo \\n
bt
echo \\n

# 测试类型混淆
echo 测试类型混淆...\\n
echo 创建不同类型笔记...\\n
continue
continue
continue
echo 删除第一个笔记...\\n
continue
echo 尝试访问已删除的笔记...\\n
continue

# 检查是否触发类型混淆
echo 检查是否触发类型混淆...\\n
info registers
echo \\n
x/10x $rsp
echo \\n
bt
echo \\n

# 退出
quit
"""
        
        with open("vulnerability_test.gdb", 'w') as f:
            f.write(gdb_commands)
        
        print("[+] 已创建漏洞测试脚本: vulnerability_test.gdb")
    
    def run_vulnerability_test(self):
        """运行漏洞测试"""
        print("[+] 运行漏洞测试...")
        
        # 创建漏洞测试脚本
        self.create_vulnerability_test_script()
        
        # 运行GDB
        cmd = f"gdb -x vulnerability_test.gdb {self.binary_path}"
        print(f"[+] 执行命令: {cmd}")
        
        try:
            subprocess.run(cmd, shell=True)
        except Exception as e:
            print(f"[-] 漏洞测试错误: {e}")
    
    def run_all_tests(self):
        """运行所有测试"""
        print("开始GDB调试测试...")
        
        try:
            # 运行内存分析
            self.run_memory_analysis()
            
            # 运行漏洞测试
            self.run_vulnerability_test()
            
            # 运行交互式GDB
            self.run_interactive_gdb()
            
        except Exception as e:
            print(f"错误: {e}")

def main():
    if len(sys.argv) != 2:
        print("用法: python3 gdb_exploit.py <binary_path>")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    if not os.path.exists(binary_path):
        print(f"错误: 文件 {binary_path} 不存在")
        sys.exit(1)
    
    exploit = GDBExploit(binary_path)
    
    print("选择调试模式:")
    print("1. 内存分析")
    print("2. 漏洞测试")
    print("3. 交互式GDB")
    print("4. pwntools GDB")
    print("5. 运行所有测试")
    
    choice = input("请选择 (1-5): ").strip()
    
    if choice == "1":
        exploit.run_memory_analysis()
    elif choice == "2":
        exploit.run_vulnerability_test()
    elif choice == "3":
        exploit.run_interactive_gdb()
    elif choice == "4":
        exploit.run_pwntools_gdb_script()
    elif choice == "5":
        exploit.run_all_tests()
    else:
        print("无效选择")

if __name__ == "__main__":
    main()
