#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
高级漏洞分析脚本
结合静态分析和动态测试
"""

import subprocess
import struct
import time
import os
import sys
from pwn import *

class AdvancedExploit:
    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.io = None
        self.notes = []  # 跟踪创建的笔记
        
    def connect(self):
        """连接到程序"""
        self.io = process(self.binary_path)
        self.io.recvuntil(b"Welcome to the All-Pwn-Red-Book App!")
        print("[+] 已连接到程序")
    
    def create_note(self, note_type, content):
        """创建笔记并跟踪"""
        self.io.sendline(b"1")
        self.io.recvuntil(b"NOTE TYPE")
        self.io.sendline(str(note_type).encode())
        self.io.recvuntil(b"Please enter note content:")
        self.io.sendline(content.encode())
        
        # 记录创建的笔记
        self.notes.append({
            'type': note_type,
            'content': content,
            'index': len(self.notes)
        })
        
        response = self.io.recvline()
        print(f"[+] 创建笔记 {len(self.notes)-1}: {response}")
        return len(self.notes) - 1
    
    def delete_note(self, note_num):
        """删除笔记"""
        if note_num < len(self.notes):
            self.io.sendline(b"5")
            self.io.recvuntil(b"Note number")
            self.io.sendline(str(note_num).encode())
            
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 删除笔记 {note_num}: {response}")
            
            # 标记为已删除
            if note_num < len(self.notes):
                self.notes[note_num] = None
    
    def test_uaf_vulnerability(self):
        """测试Use After Free漏洞"""
        print("\n=== 测试UAF漏洞 ===")
        
        # 创建笔记
        note1 = self.create_note(1, "UAF test note 1")
        note2 = self.create_note(1, "UAF test note 2")
        
        # 删除第一个笔记
        self.delete_note(note1)
        
        # 尝试访问已删除的笔记
        print("[+] 尝试访问已删除的笔记...")
        self.io.sendline(b"3")  # 显示笔记内容
        self.io.recvuntil(b"Note number")
        self.io.sendline(str(note1).encode())
        
        try:
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] UAF测试响应: {response}")
        except:
            print("[-] 程序可能崩溃了")
    
    def test_heap_spray(self):
        """测试堆喷射"""
        print("\n=== 测试堆喷射 ===")
        
        # 创建大量笔记
        for i in range(20):
            content = f"Heap spray note {i} " + "A" * 100
            self.create_note(1, content)
        
        # 删除一些笔记
        for i in range(10):
            self.delete_note(i)
        
        # 创建新笔记，可能重用已释放的内存
        new_note = self.create_note(1, "New note after spray")
        
        # 尝试访问已删除的笔记
        self.io.sendline(b"3")
        self.io.recvuntil(b"Note number")
        self.io.sendline(b"5")  # 访问已删除的笔记
        
        try:
            response = self.io.recvuntil(b"Pick your main character move")
            print(f"[+] 堆喷射测试响应: {response}")
        except:
            print("[-] 程序可能崩溃了")
    
    def test_format_string(self):
        """测试格式字符串漏洞"""
        print("\n=== 测试格式字符串漏洞 ===")
        
        # 测试各种格式字符串
        format_strings = [
            "%x" * 20,
            "%p" * 20,
            "%s" * 10,
            "%n" * 5,
            "%08x" * 20,
            "%s%p%x%d",
        ]
        
        for fmt in format_strings:
            print(f"[+] 测试格式字符串: {fmt[:50]}...")
            
            # 创建包含格式字符串的笔记
            note_id = self.create_note(1, fmt)
            
            # 尝试显示笔记内容
            self.io.sendline(b"3")
            self.io.recvuntil(b"Note number")
            self.io.sendline(str(note_id).encode())
            
            try:
                response = self.io.recvuntil(b"Pick your main character move")
                print(f"[+] 格式字符串测试响应: {response}")
            except:
                print("[-] 程序可能崩溃了")
    
    def test_buffer_overflow(self):
        """测试缓冲区溢出"""
        print("\n=== 测试缓冲区溢出 ===")
        
        # 测试不同长度的输入
        overflow_sizes = [100, 1000, 5000, 10000, 50000]
        
        for size in overflow_sizes:
            print(f"[+] 测试缓冲区溢出，大小: {size}")
            
            # 创建超长内容
            overflow_content = "A" * size
            
            try:
                note_id = self.create_note(1, overflow_content)
                print(f"[+] 成功创建超长笔记 {note_id}")
            except:
                print("[-] 创建超长笔记失败")
    
    def test_integer_overflow(self):
        """测试整数溢出"""
        print("\n=== 测试整数溢出 ===")
        
        # 测试各种整数边界值
        test_values = [
            0x7fffffff,  # 32位最大正数
            0x80000000,  # 32位最小负数
            0xffffffff,  # 32位最大无符号数
            0x100000000, # 33位
        ]
        
        for value in test_values:
            print(f"[+] 测试整数: {value} (0x{value:x})")
            
            # 尝试访问不存在的笔记
            self.io.sendline(b"3")
            self.io.recvuntil(b"Note number")
            self.io.sendline(str(value).encode())
            
            try:
                response = self.io.recvuntil(b"Pick your main character move")
                print(f"[+] 整数溢出测试响应: {response}")
            except:
                print("[-] 程序可能崩溃了")
    
    def test_type_confusion(self):
        """测试类型混淆"""
        print("\n=== 测试类型混淆 ===")
        
        # 创建不同类型的笔记
        note1 = self.create_note(1, "CheckinNotes type")
        note2 = self.create_note(2, "ProductReviews type")
        note3 = self.create_note(3, "Unknown type")
        
        # 尝试访问不同类型的笔记
        for note_id in [note1, note2, note3]:
            print(f"[+] 测试笔记 {note_id} 的类型混淆")
            
            self.io.sendline(b"3")
            self.io.recvuntil(b"Note number")
            self.io.sendline(str(note_id).encode())
            
            try:
                response = self.io.recvuntil(b"Pick your main character move")
                print(f"[+] 类型混淆测试响应: {response}")
            except:
                print("[-] 程序可能崩溃了")
    
    def test_race_condition(self):
        """测试竞态条件"""
        print("\n=== 测试竞态条件 ===")
        
        # 快速创建和删除笔记
        for i in range(10):
            note_id = self.create_note(1, f"Race test note {i}")
            self.delete_note(note_id)
            
            # 尝试访问刚删除的笔记
            self.io.sendline(b"3")
            self.io.recvuntil(b"Note number")
            self.io.sendline(str(note_id).encode())
            
            try:
                response = self.io.recvuntil(b"Pick your main character move")
                print(f"[+] 竞态条件测试响应: {response}")
            except:
                print("[-] 程序可能崩溃了")
    
    def run_comprehensive_test(self):
        """运行综合测试"""
        print("开始综合漏洞测试...")
        
        try:
            self.connect()
            
            # 运行各种测试
            self.test_uaf_vulnerability()
            self.test_heap_spray()
            self.test_format_string()
            self.test_buffer_overflow()
            self.test_integer_overflow()
            self.test_type_confusion()
            self.test_race_condition()
            
            print("\n=== 测试完成 ===")
            
        except Exception as e:
            print(f"错误: {e}")
        finally:
            if self.io:
                self.io.close()

def main():
    if len(sys.argv) != 2:
        print("用法: python3 advanced_exploit.py <binary_path>")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    if not os.path.exists(binary_path):
        print(f"错误: 文件 {binary_path} 不存在")
        sys.exit(1)
    
    exploit = AdvancedExploit(binary_path)
    exploit.run_comprehensive_test()

if __name__ == "__main__":
    main()

